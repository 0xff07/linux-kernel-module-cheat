#!/usr/bin/env bash

set -e

# CLI handling.
debug=false
nographic=false
extra_append=''
extra_flags=''
while getopts dn OPT; do
  case "$OPT" in
    d)
      debug=true
      extra_flags="$extra_flags -S -s"
      ;;
    n)
      extra_append="$extra_append console=ttyS0"
      extra_flags="$extra_flags -nographic"
      nographic=true
      ;;
  esac
done

# If we turn on buildroot host QEMU some day.
#cmd="./buildroot/output/host/usr/bin/qemu-system-x86_64 \
#cmd="qemu-system-x86_64 \
#-M pc \
#-net nic,model=virtio \
#-kernel buildroot/output/images/bzImage \
#cmd="qemu-system-arm \
  #-M vexpress-a9 \
  #-append 'root=/dev/vda $extra_append' \
  #-drive file=buildroot/output/images/rootfs.ext2,if=virtio,format=raw \
  #-kernel buildroot/output/images/zImage \
  #-m 128M \
  #-net user \
  #-smp 1 \
  #$extra_flags \
#;
#"

# TODO window opens, but hangs.
qemu-system-arm \
  -M vexpress-a9 \
  -kernel buildroot/output/images/zImage \
  -dtb buildroot/output/images/vexpress-v2p-ca9.dtb \
  -drive file=buildroot/output/images/rootfs.ext2,if=scsi,format=raw \
  -append "root=/dev/sda console=ttyAMA0,115200" \
  -serial stdio \
;
#-net nic,model=rtl8139 \
#-net user \

if $debug && ! $nographic; then
  eval nohup "$cmd" &>/dev/null &
  # TODO: Ctrl +C gets sent to QEMU? Why? Does not happen if I run
  # ./rungdb manually from outside this script!!! But why?!?!
  # eval has nothing to do with it, minimized example with explicit
  # commands also fails in the same way...
  #./rungdb
else
  eval "$cmd"
fi
